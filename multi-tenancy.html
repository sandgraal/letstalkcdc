<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Tenant CDC Architectures | A Deep Dive Series</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Global Header -->
    <header class="global-header">
      <div class="nav-container">
        <a href="index.html" class="site-title">CDC: The Missing Manual</a>
        <nav class="nav-links">
          <a href="index.html">Home</a>
          <a href="overview.html" class="active">The Series</a>
        </nav>
      </div>
    </header>

    <main>
      <article class="prose">
        <a href="overview.html">&larr; Back to Series Overview</a>
        <h1 style="margin-top: 1rem">
          Deep Dive: Multi-Tenant CDC Architectures
        </h1>

        <p class="text-xl text-slate-600">
          When you move from a single CDC pipeline to serving dozens or hundreds
          of tenants—be they internal teams or external customers—the
          architectural challenges multiply. A naive approach will quickly lead
          to resource contention, security risks, and operational chaos. A
          robust multi-tenant architecture is essential for scaling CDC
          effectively.
        </p>

        <h2>The Core Challenge: Isolation vs. Efficiency</h2>
        <p>
          Multi-tenancy is a balancing act. You need to provide each tenant with
          a logically isolated pipeline, ensuring their data and performance are
          unaffected by others. At the same time, you want to maximize resource
          utilization and minimize operational overhead by sharing
          infrastructure where possible.
        </p>

        <h3>Model 1: Fully Isolated Stacks</h3>
        <p>
          In this model, each tenant gets a completely separate stack: their own
          CDC connector, message broker topics, and processing jobs. This offers
          maximum isolation and security but comes at a high operational cost
          and can lead to underutilized resources.
        </p>
        <ul>
          <li>
            <strong>Pros:</strong> Strongest security and performance isolation.
            Simple to reason about.
          </li>
          <li>
            <strong>Cons:</strong> Expensive. Operationally complex to manage
            hundreds of stacks.
          </li>
        </ul>

        <h3>Model 2: Shared Infrastructure with Logical Separation</h3>
        <p>
          A more common and efficient approach is to share the core
          infrastructure (like a Kafka cluster and a processing engine) while
          using logical constructs to isolate tenants. This could involve:
        </p>
        <ul>
          <li>
            <strong>Tenant-Specific Topics:</strong> Each tenant's data flows
            into a dedicated Kafka topic (e.g.,
            <code>cdc.tenant_a.orders</code>).
          </li>
          <li>
            <strong>Tenant ID in Messages:</strong> A single topic is used, but
            every message is enriched with a <code>tenant_id</code> field.
            Downstream consumers use this ID to filter and process data.
          </li>
          <li>
            <strong>Access Control Lists (ACLs):</strong> Enforce which
            consumers can read from which topics, preventing data leakage.
          </li>
        </ul>

        <blockquote>
          <strong>Key Decision:</strong> The choice between a single topic with
          a tenant ID versus per-tenant topics depends on the number of tenants
          and the volume of data. Per-tenant topics offer better isolation and
          throughput control but can be harder to manage at extreme scale
          (thousands of tenants).
        </blockquote>

        <h2>Schema Management in a Multi-Tenant World</h2>
        <p>
          When multiple tenants use the same table structure, a shared schema
          registry works well. However, if tenants can extend or modify their
          schemas, you need a strategy to manage these variations without
          breaking the pipeline. This often involves a central schema registry
          that supports multiple versions and robust validation on the producer
          side to prevent schema drift.
        </p>

        <!-- Pagination -->
        <div class="pagination">
          <a href="exactly-once.html" class="prev">&larr; Prev: Exactly-Once</a>
          <a href="#" class="next disabled">Next: Partitioning &rarr;</a>
        </div>
      </article>
    </main>

    <!-- Footer -->
    <footer class="site-footer">
      <p>
        &copy; 2025 Your Name. A deep dive into the world of Change Data
        Capture.
      </p>
    </footer>
  </body>
</html>
