<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>CDC Nuances & Errata — Read Before You Ship</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="Corrections, caveats, and sharp edges in CDC systems."
    />
    <link rel="canonical" href="https://letstalkcdc.nfshost.com/errata.html" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <a class="skip-link" href="#main">Skip to content</a>
    <header class="global-header">
      <div class="nav-container">
        <a href="index.html" class="site-title">CDC: The Missing Manual</a>
        <div class="nav-right">
          <nav class="nav-links" aria-label="Primary">
            <a href="overview.html">The Series</a>
            <a href="lab-kafka-debezium.html">Hands‑on Lab</a>
            <a href="tests.html">Acceptance Tests</a>
            <a href="errata.html" aria-current="page">Nuances & Errata</a>
          </nav>
        </div>
      </div>
    </header>
    <main id="main">
      <h1>Nuances & Errata</h1>
      <p class="lede">
        A living list of precise clarifications, corrections, and “gotchas”.
        Treat this as pre‑flight checks before promising
        <em>exactly‑once</em> or “zero data loss.”
      </p>

      <section class="panel">
        <h2>End‑to‑end <em>exactly‑once</em> vs. <em>effectively‑once</em></h2>
        <ul>
          <li>
            <strong>Source connectors are at‑least‑once</strong> in practice.
            You can achieve <em>effectively‑once</em> by making sinks idempotent
            (UPSERT on stable keys) and/or <em>deduplicating</em> using a
            durable <code>event_id</code> ledger.
          </li>
          <li>
            <strong>Transaction boundaries</strong>: Database transactions map
            to change streams, not to sink transactions unless your pipeline
            coordinates them. Don’t assume cross‑topic atomicity.
          </li>
          <li>
            <strong>Per‑key ordering only</strong>: Ordering is guaranteed per
            partition key (primary/business key). <em>Cross‑entity</em> ordering
            is not guaranteed and shouldn’t be relied upon.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Snapshots, backfills, and replays</h2>
        <ul>
          <li>
            <strong>Initial snapshots</strong> can interleave with live changes;
            design consumers to reconcile using version columns or
            <code>op_ts</code>.
          </li>
          <li>
            <strong>Incremental snapshots</strong> (signal‑based) are powerful
            but can produce duplicates; always merge on keys + highest version
            and keep idempotent sinks.
          </li>
          <li>
            <strong>Backfills</strong> are just another snapshot; isolate them
            (topics/headers) to avoid double‑counting.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Tombstones, compaction, and deletions</h2>
        <ul>
          <li>
            <strong>Tombstones</strong> are required for compaction to fully
            remove keys; keep a non‑zero delete.retention.ms long enough for
            consumers.
          </li>
          <li>
            <strong>Soft‑delete models</strong> still need physical deletes or a
            retention strategy in the sink to avoid data resurrection.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Schema evolution</h2>
        <ul>
          <li>
            Always version <em>payload schemas</em> and keep consumers tolerant
            to <em>additive</em> changes. No producer should introduce breaking
            field removals/renames without a migration window.
          </li>
          <li>
            Use <code>optional</code> + default values judiciously to avoid
            “poison” events.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Operational guardrails</h2>
        <ul>
          <li>
            Watch lag/throughput and <code>max.queue.size</code>,
            <code>max.batch.size</code>, <code>poll.interval.ms</code>.
            Oversizing queue without heap tuning yields GC stalls.
          </li>
          <li>
            Alert on <strong>connector task failures</strong>,
            <strong>restart loops</strong>, and
            <strong>earliest‑offset resets</strong>.
          </li>
          <li>
            Prefer <strong>per‑table connectors</strong> for isolation when SLAs
            differ; otherwise group by SLA and update cadence.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Recommended dedup ledger</h2>
        <pre><code>-- event_id is a stable UUID in headers or payload
create table if not exists dw.processed_event(
  event_id text primary key,
  processed_at timestamptz not null default now()
);</code></pre>
        <p>On ingest:</p>
        <pre><code>insert into dw.processed_event(event_id)
values (:event_id)
on conflict do nothing;</code></pre>
      </section>

      <div class="links" aria-label="useful extras">
        <a href="compose.yaml" download>compose.yaml</a>
        <a href="connectors/postgres-inventory.json" download
          >postgres sample connector</a
        >
        <a href="scripts/register_connector.sh" download
          >register connector script</a
        >
      </div>
    </main>
    <script src="app.js" defer></script>
  </body>
</html>
