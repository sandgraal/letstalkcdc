<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- SEO Tags -->
    <title>
      Architecting Multi-Tenant CDC Pipelines | CDC: The Missing Manual
    </title>
    <meta
      name="description"
      content="Explore architectural patterns for building scalable, multi-tenant Change Data Capture (CDC) systems. Compare isolation models and schema management strategies."
    />

    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Global Header -->
    <header class="global-header">
      <div class="nav-container">
        <a href="index.html" class="site-title">CDC: The Missing Manual</a>
        <nav class="nav-links">
          <a href="index.html">Home</a>
          <a href="overview.html" class="active">The Series</a>
        </nav>
      </div>
    </header>

    <div class="article-container">
      <!-- Series Progress Sidebar -->
      <aside class="series-nav">
        <h3>Part 2 Articles</h3>
        <ul>
          <li><a href="exactly-once.html">1. Exactly-Once Semantics</a></li>
          <li>
            <a href="multi-tenancy.html" class="active"
              >2. Multi-Tenant Architectures</a
            >
          </li>
          <li><a href="#" class="disabled">3. Partitioning Strategies</a></li>
          <li><a href="#" class="disabled">4. Auditing & Reconciliation</a></li>
        </ul>
      </aside>

      <!-- Main Article Content -->
      <main>
        <article class="prose">
          <h1 style="margin-top: 0">
            Deep Dive: Multi-Tenant CDC Architectures
          </h1>
          <p class="text-xl text-slate-600">
            When you move from a single CDC pipeline to serving dozens or
            hundreds of tenants—be they internal teams or external customers—the
            architectural challenges multiply. A naive approach will quickly
            lead to resource contention, security risks, and operational chaos.
            A robust multi-tenant architecture is essential for scaling CDC
            effectively.
          </p>

          <h2>The Core Challenge: Isolation vs. Efficiency</h2>
          <p>
            Multi-tenancy is a balancing act. You need to provide each tenant
            with a logically isolated pipeline, ensuring their data and
            performance are unaffected by others. At the same time, you want to
            maximize resource utilization and minimize operational overhead by
            sharing infrastructure where possible.
          </p>

          <h3>Model 1: Fully Isolated Stacks</h3>
          <p>
            In this model, each tenant gets a completely separate stack: their
            own CDC connector, message broker topics, and processing jobs. This
            offers maximum isolation and security but comes at a high
            operational cost and can lead to underutilized resources.
          </p>

          <h3>Model 2: Shared Infrastructure with Logical Separation</h3>
          <p>
            A more common and efficient approach is to share the core
            infrastructure (like a Kafka cluster and a processing engine) while
            using logical constructs to isolate tenants. This could involve
            tenant-specific topics or a tenant ID within a shared message
            stream.
          </p>

          <blockquote>
            <strong>Key Decision:</strong> The choice between a single topic
            with a tenant ID versus per-tenant topics depends on the number of
            tenants and the volume of data. Per-tenant topics offer better
            isolation and throughput control but can be harder to manage at
            extreme scale.
          </blockquote>

          <h2>Schema Management in a Multi-Tenant World</h2>
          <p>
            When multiple tenants use the same table structure, a shared schema
            registry works well. However, if tenants can extend or modify their
            schemas, you need a strategy to manage these variations without
            breaking the pipeline. This often involves a central schema registry
            that supports multiple versions and robust validation on the
            producer side to prevent schema drift.
          </p>

          <!-- Pagination -->
          <div class="pagination">
            <a href="exactly-once.html" class="prev"
              >&larr; Prev: Exactly-Once</a
            >
            <a href="#" class="next disabled">Next: Partitioning &rarr;</a>
          </div>
        </article>
      </main>
    </div>

    <!-- Footer -->
    <footer class="site-footer">
      <p>
        &copy; 2025 Christopher Ennis. A deep dive into the world of Change Data
        Capture.
      </p>
    </footer>
    <!-- Add near the end of <body> on all pages -->
    <script type="module">
      // --- Dark mode toggle ---
      const apply = (m) => (document.documentElement.dataset.theme = m);
      const saved = localStorage.getItem("theme");
      const prefersDark = matchMedia("(prefers-color-scheme: dark)").matches;
      apply(saved ?? (prefersDark ? "dark" : "light"));
      document.addEventListener("click", (e) => {
        if (e.target.matches("[data-toggle-theme]")) {
          const next =
            document.documentElement.dataset.theme === "dark"
              ? "light"
              : "dark";
          apply(next);
          localStorage.setItem("theme", next);
        }
      });

      // --- Reduced motion guard for animations ---
      const reduceMotion = matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;
      if (reduceMotion) document.documentElement.classList.add("reduce-motion");

      // --- Copy buttons for code ---
      document.querySelectorAll("pre > code").forEach((code) => {
        const btn = Object.assign(document.createElement("button"), {
          textContent: "Copy",
          className: "copy-btn",
        });
        const pre = code.parentElement;
        pre.style.position = "relative";
        pre.appendChild(btn);
        btn.addEventListener("click", async () => {
          await navigator.clipboard.writeText(code.innerText);
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 1200);
        });
      });

      // --- Heading anchors ---
      document.querySelectorAll(".prose h2, .prose h3").forEach((h) => {
        const id =
          h.id ||
          h.textContent
            .toLowerCase()
            .trim()
            .replace(/[^a-z0-9]+/g, "-");
        h.id = id;
        const a = Object.assign(document.createElement("a"), {
          href: `#${id}`,
          className: "anchor",
          ariaLabel: "Link to section",
        });
        h.appendChild(a);
      });

      // --- Lightweight search (builds an index from links + headings) ---
      const pages = [
        "index.html",
        "overview.html",
        "exactly-once.html",
        "multi-tenancy.html",
      ];
      async function buildIndex() {
        const docs = await Promise.all(
          pages.map((p) =>
            fetch(p, { credentials: "omit" })
              .then((r) => r.text())
              .then((html) => ({ p, html }))
          )
        );
        return docs.map(({ p, html }) => {
          const tmp = document.createElement("div");
          tmp.innerHTML = html;
          const title = (tmp.querySelector("title")?.textContent || "").trim();
          const text = Array.from(
            tmp.querySelectorAll(
              ".prose p, .prose li, .prose h1, .prose h2, .prose h3"
            )
          )
            .map((n) => n.textContent.trim())
            .join(" ");
          return { p, title, text: text.slice(0, 50000) }; // cap to keep it snappy
        });
      }
      const searchBox = document.querySelector("#site-search");
      const resultsBox = document.querySelector("#search-results");
      if (searchBox && resultsBox) {
        const index = await buildIndex();
        searchBox.addEventListener("input", (e) => {
          const q = e.target.value.trim().toLowerCase();
          resultsBox.innerHTML = "";
          if (!q) return;
          const hits = index
            .map((d) => {
              const i = d.text.toLowerCase().indexOf(q);
              const ctx =
                i > 40 ? d.text.slice(i - 40, i + 160) : d.text.slice(0, 200);
              return { score: i === -1 ? Infinity : i, d, ctx };
            })
            .filter((h) => h.score !== Infinity)
            .sort((a, b) => a.score - b.score)
            .slice(0, 6);
          hits.forEach(({ d, ctx }) => {
            const li = document.createElement("li");
            li.innerHTML = `<a href="${d.p}">${
              d.title || d.p
            }</a><div class="hit">${ctx.replaceAll(
              q,
              `<mark>${q}</mark>`
            )}</div>`;
            resultsBox.appendChild(li);
          });
        });
      }
    </script>
  </body>
</html>
