<!DOCTYPE html>
<html lang="en" data-path-prefix="/letstalkcdc/">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Schema Evolution | CDC: The Missing Manual | CDC: The Missing Manual</title>
    <meta name="description" content="Learn why Change Data Capture (CDC) projects fail and how to build scalable, reliable, and production-ready data pipelines.">
    <meta name="robots" content="index,follow,max-image-preview:large">
    <link rel="apple-touch-icon" sizes="180x180" href="/letstalkcdc/apple-touch-icon.png">
    <link rel="icon" href="/letstalkcdc/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="/letstalkcdc/favicon.ico">
    
    
      
      
    
    
    <link rel="canonical" href="https://letstalkcdc.github.io/letstalkcdc/schema-evolution/">
    <meta name="theme-color" content="#0f172a">
    <meta
      content="Learn how to handle schema drift and evolution in CDC pipelines using a Schema Registry to prevent breakages."
      name="description"
    />
    <link rel="stylesheet" href="{{ '/assets/css/pages/schema-evolution.css' | url }}">

    <link rel="stylesheet" href="/letstalkcdc/assets/css/styles.css">
    <link rel="stylesheet" href="/letstalkcdc/css/dashboard.css">
  </head>
  <body data-journey-slug="schema-evolution">
    <a class="skip-link" href="#main">Skip to content</a>
    <header class="global-header">
      <div class="nav-container">
        <a class="site-title" href="/letstalkcdc/">CDC: The Missing Manual | A Deep Dive into Change Data Capture</a>
        <div class="nav-right">
          <nav aria-label="Primary" class="nav-links">
            <a class="" href="/letstalkcdc/">Home</a>
            <a class="" href="/letstalkcdc/overview/">The Series</a>
          </nav>
          <button aria-label="Toggle dark mode" class="theme-toggle" data-toggle-theme type="button">üåì</button>
        </div>
      </div>
    </header>

    <main id="main">


  <section class="hero-section hero-align-center">
    <div class="hero-container container">
      <div class="prose">
        
        <h1 class="type-display">Handling Schema Evolution in CDC</h1>
        
          <div class="hero-lede"><p>Keep downstream systems humming as source schemas change. Learn how schema registries, compatibility modes, and message contracts safeguard your pipelines from drift.</p></div>
        
        
          <div class="hero-actions">
            
              <a class="button " href="#solution">Use a Schema Registry</a>
            
              <a class="button ghost" href="#compatibility">Choose Compatibility Modes</a>
            
          </div>
        
      </div>
    </div>
  </section>

      <article class="prose">
        <p>
          Source database schemas are not static. Over the lifecycle of an
          application, developers will inevitably make changes: adding new
          columns, removing old ones, or modifying data types. This phenomenon,
          known as <strong>schema drift</strong> or
          <strong>schema evolution</strong>, is a primary cause of brittle data
          pipelines. A pipeline not designed for this will break the moment an
          incoming change event no longer matches what downstream consumers
          expect.
        </p>

        <h2 id="solution">
          The Solution: The Schema Registry (An API Contract for Your Data)
        </h2>
        <p>
          The industry-standard solution is to treat your data's schema like a
          formal API contract. This is managed by a
          <strong>Schema Registry</strong>. Think of it as the 'OpenAPI' or
          'Swagger' for your event streams. It's a centralized service that
          ensures all data producers and consumers agree on the 'shape' of the
          data, even as that shape evolves over time.
        </p>
        <p>
          By using a schema-aware format like Apache Avro or Protobuf, producers
          and consumers can be decoupled, allowing them to evolve independently
          without breaking the pipeline.
        </p>

        <h2 id="compatibility">
          Choosing Your Contract Strategy: Compatibility Modes
        </h2>
        <p>
          A schema registry isn't just a database of schemas; it actively
          enforces rules. When a producer tries to register a new schema
          version, the registry checks it against a configured compatibility
          mode. Understanding these modes is critical for operations.
        </p>

        <div class="compatibility-modes">
          <div class="mode-card">
            <h3>Backward Compatibility</h3>
            <p><em>(New schemas can read old data)</em></p>
            <p>
              This mode allows you to <strong>delete fields</strong> and
              <strong>add optional new fields</strong> (with a default value).
              Consumers can upgrade at their own pace without breaking when they
              encounter old data.
            </p>
            <p>
              <strong>Use this for most standard use cases.</strong> It offers
              the most operational flexibility.
            </p>
          </div>
          <div class="mode-card">
            <h3>Forward Compatibility</h3>
            <p><em>(Old schemas can read new data)</em></p>
            <p>
              This mode allows you to <strong>add new fields</strong> and
              <strong>delete optional old fields</strong>. This is less common
              and requires careful coordination, as you must upgrade all
              consumers <em>before</em> producers start sending data with the
              new schema.
            </p>
          </div>
          <div class="mode-card">
            <h3>Full Compatibility</h3>
            <p><em>(Both backward and forward)</em></p>
            <p>
              Ensures old consumers can read new data and new consumers can read
              old data. Safest‚Äîbut most restrictive. Good for long-lived topics
              with many consumers.
            </p>
          </div>
          <div class="mode-card">
            <h3>Transitive vs Latest</h3>
            <p>
              <strong>Transitive</strong> checks a new schema against
              <em>all</em> previous versions. <strong>Latest</strong> checks
              only against the most recent version. Prefer transitive for
              critical topics to avoid ‚Äúdrift over time.‚Äù
            </p>
          </div>
        </div>
        <p>
          For most CDC pipelines,
          <strong>start with Backward (often transitive)</strong>. It balances
          safety with agility, letting consumers upgrade at their own pace while
          preventing breaking producer changes.
        </p>
        <h2 id="subject-naming">Subject naming &amp; scope</h2>
        <p>
          Compatibility is enforced per <em>subject</em> (a Registry namespace).
          Common strategies:
        </p>
        <ul>
          <li>
            <strong>TopicNameStrategy:</strong>
            <code>&lt;topic&gt;-value</code> (simple, one record type per
            topic).
          </li>
          <li>
            <strong>RecordNameStrategy:</strong> record‚Äôs full name is the
            subject (lets multiple record types share a topic).
          </li>
          <li>
            <strong>TopicRecordNameStrategy:</strong> combines both (avoids name
            clashes across topics).
          </li>
        </ul>
        <p class="muted">
          Pick once per topic family‚Äîchanging later is painful.
        </p>

        <h2 id="flow">The Data Flow in a Schema-Aware Pipeline</h2>
        <div class="seq" role="group" aria-label="Schema-aware flow">
          <div class="seq-head">Producer</div>
          <div class="seq-head">Schema Registry</div>
          <div class="seq-head">Consumer</div>

          <!-- Row 1 -->
          <div class="seq-cell">Register <code>user_v1</code></div>
          <div class="seq-cell">Store &amp; return <code>id=1</code></div>
          <div class="seq-cell">‚Äî</div>

          <!-- Row 2 -->
          <div class="seq-cell">Serialize with id=1 ‚Üí publish</div>
          <div class="seq-cell">‚Äî</div>
          <div class="seq-cell">Read message (id=1)</div>

          <!-- Row 3 -->
          <div class="seq-cell">‚Äî</div>
          <div class="seq-cell">Return schema 1</div>
          <div class="seq-cell">
            If not cached: request id=1 ‚Üí cache ‚Üí deserialize
          </div>
        </div>

        <h3 id="upgrade">Upgrade to v2</h3>
        <div class="seq" role="group" aria-label="Upgrade to v2">
          <div class="seq-head">Producer</div>
          <div class="seq-head">Schema Registry</div>
          <div class="seq-head">Consumer</div>

          <div class="seq-cell">Register <code>user_v2</code></div>
          <div class="seq-cell">Compat check ‚Üí <code>id=2</code></div>
          <div class="seq-cell">‚Äî</div>

          <div class="seq-cell">Publish id=2</div>
          <div class="seq-cell">‚Äî</div>
          <div class="seq-cell">
            If unseen: fetch id=2 ‚Üí cache ‚Üí deserialize
          </div>
        </div>
        <p>
          This flow, mediated by the schema registry, allows a producer to
          upgrade to a `v2` schema and start sending messages with ID `2`. An
          old consumer that only knows about ID `1` can either fail gracefully
          or, if the schemas are compatible, process the new message by ignoring
          the new fields.
        </p>
        <h2 id="examples">Concrete evolution examples</h2>
        <div class="code-comparison">
          <div>
            <h3>Avro (v1 ‚Üí v2)</h3>
            <pre><code>// v1
{ "type":"record","name":"User","namespace":"demo",
  "fields":[
    {"name":"id","type":"long"},
    {"name":"email","type":"string"}
  ] }
// v2 (backward-compatible): add optional with default; rename with alias
{ "type":"record","name":"User","namespace":"demo",
  "fields":[
    {"name":"id","type":"long"},
    {"name":"email","type":"string"},
    {"name":"full_name","type":["null","string"],"default":null,
     "aliases":["name"]} ] }</code></pre>
            <p class="muted">
              OK under backward/backward_transitive. Dropping a required field
              would violate it.
            </p>
          </div>
          <div>
            <h3>Protobuf (field numbers matter)</h3>
            <pre><code>// v1
message User { int64 id = 1; string email = 2; }
// v2 (safe): add new optional field, keep numbers stable
message User { int64 id = 1; string email = 2; string full_name = 3; }</code></pre>
            <p class="muted">
              Never reuse or renumber fields; removing a field keeps the tag
              reserved.
            </p>
          </div>
        </div>
        <div class="code-comparison">
          <div>
            <h3>JSON Schema (tolerant readers)</h3>
            <pre><code>{ "$schema":"https://json-schema.org/draft/2020-12/schema",
  "type":"object",
  "properties":{
    "id":{"type":"integer"},
    "email":{"type":"string"},
    "full_name":{"type":["string","null"]}
  },
  "required":["id","email"],
  "additionalProperties": true }</code></pre>
            <p class="muted">
              Set <code>additionalProperties</code> per policy. Many JSON
              consumers ignore unknown fields‚Äîdocument the expectation.
            </p>
          </div>
        </div>

        <h2 id="rollouts">Safe rollout playbooks</h2>
        <ul>
          <li>
            <strong>Read-new / Write-old (RN/WO):</strong> upgrade consumers
            first to tolerate the new schema; then upgrade producers.
          </li>
          <li>
            <strong>Two-phase add:</strong> add optional fields with defaults ‚Üí
            backfill downstream ‚Üí switch producers to start populating.
          </li>
          <li>
            <strong>Type widening:</strong> e.g., <code>int‚Üílong</code> or
            <code>string‚Üí[string,null]</code>; avoid narrowing.
          </li>
          <li>
            <strong>Removals:</strong> deprecate ‚Üí stop usage ‚Üí drop only if
            policy allows and all consumers have moved.
          </li>
        </ul>

        <h2 id="registry-ops">Registry operations (quick refs)</h2>
        <pre><code># Set per-subject compatibility (examples)
curl -X PUT -H "Content-Type: application/json" \
  --data '{"compatibility":"BACKWARD_TRANSITIVE"}' \
  $REGISTRY_URL/config/your-subject

# Get the current compatibility
curl $REGISTRY_URL/config/your-subject
</code></pre>
        <p class="muted">
          Automate these in CI so topics can‚Äôt drift to unsafe modes.
        </p>

        <h2 id="cdc-notes">CDC-specific wrinkles</h2>
        <ul>
          <li>
            <strong>New source columns:</strong> existing rows will emit
            <code>null</code> until updated or backfilled‚Äîplan materialization
            defaults.
          </li>
          <li>
            <strong>Rename vs drop:</strong> prefer
            <em>add new + alias</em> (Avro) and keep the old field until
            consumers migrate.
          </li>
          <li>
            <strong>Envelope stability:</strong> keep event envelope fields
            (op/ts_ms/transaction/key) stable; evolve payload separately.
          </li>
        </ul>

        <h2 id="consumer-defenses">Consumer defenses</h2>
        <ul>
          <li>
            <strong>Ignore unknown fields:</strong> choose deserializers/options
            that tolerate extras.
          </li>
          <li>
            <strong>Defaulting:</strong> when a field is missing, apply a
            deterministic default (document it!).
          </li>
          <li>
            <strong>Quarantine on hard breaks:</strong> route to DLQ with schema
            id and error for later replay.
          </li>
        </ul>

        <details>
          <summary><strong>Audit &amp; test</strong></summary>
          <ul>
            <li>
              Contract tests: validate proposed schemas against real consumer
              fixtures.
            </li>
            <li>
              Canary topics: mirror a subset of prod through the new schema and
              compare sink MERGE row counts/checksums.
            </li>
          </ul>
        </details>
      </article>
</main>

    
      



  

  

  

  

  

  

  

  
    
    
  

  

  

  

  

  

  

  

  

  

  

  

  


  
  
  <div class="container">
    <nav class="series-nav" aria-label="Series navigation">
      <div class="series-nav__group series-nav__group--start">
        
          <a class="series-nav__link series-nav__link--prev" href="/partitioning/" aria-label="Previous module: Partitioning">‚Üê Partitioning</a>
        
      </div>
      <div class="series-nav__group series-nav__group--center">
        <a
          class="series-nav__link series-nav__link--overview"
          href="/letstalkcdc/overview/#series-schema-evolution"
        >
          Back to Overview
        </a>
      </div>
      <div class="series-nav__group series-nav__group--end">
        
          <a class="series-nav__link series-nav__link--next" href="/ops-offsets/" aria-label="Next module: Ops: Offsets &amp; Replays">Ops: Offsets &amp; Replays ‚Üí</a>
        
      </div>
    </nav>
    <div class="series-progress" data-progress-toolbar>
      <div class="series-progress__info">
        <span class="series-progress__label">Progress</span>
        <span class="series-progress__value" data-progress-percent>0%</span>
        <span class="series-progress__status" data-progress-status>Not signed in</span>
      </div>
      <div class="series-progress__auth">
        <button type="button" class="button ghost" data-progress-login="github">Sign in with GitHub</button>
        <button type="button" class="button ghost" data-progress-logout hidden>Sign out</button>
      </div>
    </div>
  </div>


    

    <div class="progress-toast" data-progress-toast hidden aria-live="polite">
      <div class="progress-toast__body" role="status">
        <p class="progress-toast__message" data-progress-toast-message></p>
        <div class="progress-toast__actions">
          <button type="button" class="button" data-progress-toast-resume>Resume</button>
          <button type="button" class="button ghost" data-progress-toast-dismiss>Dismiss</button>
        </div>
      </div>
    </div>

    <section class="dashboard-boot container" id="cdcDashboardBoot" aria-live="polite">
      <h2>Let&rsquo;s Talk CDC Session</h2>
      <p>Sign in with your CDC account to unlock the interactive dashboard and sync module progress across devices.</p>
    </section>

    <section class="cdc-dashboard container" id="cdcDashboard" hidden aria-labelledby="cdcDashboardTitle">
      <header>
        <h2 id="cdcDashboardTitle">Let&rsquo;s Talk CDC Interactive Dashboard</h2>
        <p>Track journey completion, monitor recent activity, and export your session logs.</p>
      </header>
      <div class="dashboard-charts">
        <canvas id="cdc-progress-overall" aria-label="Overall progress" role="img"></canvas>
        <canvas id="cdc-progress-modules" aria-label="Module progress" role="img"></canvas>
      </div>
      <div class="dashboard-legend" id="progressLegend" aria-live="polite"></div>
      <div class="dashboard-footer" id="progressFooter" data-last-completed="0" aria-live="polite"></div>
      <div class="agent-console" id="agentConsole" aria-live="polite">
        <div class="agent-scroll" role="log" aria-live="polite" aria-label="CDC agent activity"></div>
      </div>
    </section>

    <div class="stats-wrapper" aria-live="polite">
      <button type="button" class="stats-chip" id="statsButton" aria-haspopup="dialog" aria-controls="sessionModal">
        <span class="sr-only">Open dashboard activity</span>
        <span aria-hidden="true">üìä</span>
        <span class="stats-counter" id="statsCounter">0</span>
      </button>
      <div class="filter-tooltip" id="filterTooltip" role="status" aria-live="assertive">FILTER: all</div>
    </div>

    <div class="session-modal hidden" id="sessionModal" role="dialog" aria-modal="true" aria-labelledby="sessionModalTitle">
      <div class="modal-content">
        <header>
          <h2 id="sessionModalTitle">Session Activity</h2>
        </header>
        <div id="sessionDetails"></div>
        <div class="export-controls">
          <button type="button" id="exportTxt">Export TXT</button>
          <button type="button" id="exportJson">Export JSON</button>
        </div>
        <button type="button" class="button ghost" id="closeModal">Close</button>
      </div>
    </div>

    <script>
      (function () {
        const attr = document.documentElement.dataset.pathPrefix || '/';
        const prefix = attr === '/' ? '' : attr.replace(/\/$/, '');
        window.__PATH_PREFIX__ = prefix;

        if (!prefix) {
          return;
        }

        const rewriteAttribute = (element, attribute) => {
          const value = element.getAttribute(attribute);
          if (!value || value.startsWith('http') || value.startsWith('mailto:') || value.startsWith('tel:') || value.startsWith('#')) {
            return;
          }
          if (!value.startsWith('/') || value.startsWith(prefix)) {
            return;
          }
          element.setAttribute(attribute, `${prefix}${value}`);
        };

        const adjustDom = () => {
          document.querySelectorAll('a[href^="/"]').forEach((el) => rewriteAttribute(el, 'href'));
          document.querySelectorAll('img[src^="/"]').forEach((el) => rewriteAttribute(el, 'src'));
          document.querySelectorAll('script[src^="/"]').forEach((el) => rewriteAttribute(el, 'src'));
          document.querySelectorAll('form[action^="/"]').forEach((el) => rewriteAttribute(el, 'action'));
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', adjustDom, { once: true });
        } else {
          adjustDom();
        }
      })();
    </script>
    <script>
      window.CDC_MODULES = [{"key":"intro","title":"Interactive Introduction to CDC","description":"An interactive dashboard covering core concepts, methods, architectures, and the tooling ecosystem.","href":"/intro/","ctaLabel":"Dive In!","isRecommended":true,"badge":{"label":"Start Here","variant":"recommended"},"tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"event-envelope","title":"Event Envelope & Delivery Guarantees","description":"Keys vs payload, before/after images, tombstones; ALO vs EOS scope and per-key ordering.","href":"/event-envelope/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"materialization","title":"Materialization 101 (Upsert/Delete)","description":"Practical MERGE patterns for upserts & deletes; compaction vs history tables; late-arrivals 101.","href":"/materialization/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"snapshotting","title":"Snapshotting: The First Sync","description":"Learn how CDC pipelines perform the initial, consistent snapshot of a database before streaming live changes.","href":"/snapshotting/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"exactly-once","title":"Exactly-Once Semantics","description":"Visual walkthrough of ALO vs EOS + transactional outbox.","href":"/exactly-once/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"multi-tenancy","title":"Multi-Tenancy","description":"Isolation patterns, topic math, and rough egress estimates.","href":"/multi-tenancy/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"partitioning","title":"Partitioning","description":"Partition keys, skew, late-arrivals, and audit loops.","href":"/partitioning/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"schema-evolution","title":"Schema Evolution","description":"Handle schema changes gracefully with forward/backward compatibility and schema registries.","href":"/schema-evolution/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"ops-offsets","title":"Ops: Offsets & Replays","description":"Offset stores, safe rewind, idempotency, and resync drills when things go sideways.","href":"/ops-offsets/","tags":[{"label":"Ops","variant":"tag-ops"}]},{"key":"observability","title":"Observability Basics","description":"Golden signals (lag, throughput, error rate), alerting, and minimal dashboards to keep.","href":"/observability/","tags":[{"label":"Ops","variant":"tag-ops"}]},{"key":"use-cases","title":"Real-World Use Cases","description":"Explore practical applications of CDC, from real-time analytics to cache invalidation.","href":"/use-cases/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"strategy","title":"The Strategic Value of CDC","description":"Understand the business case and philosophical shift behind adopting an event-driven data culture.","href":"/strategy/","tags":[{"label":"Strategy","variant":"tag-strategy"}]},{"key":"tooling","title":"The CDC Ecosystem","description":"A curated overview of the most popular open-source and commercial tools in the landscape (Debezium, Fivetran, etc).","href":"/tooling/","tags":[{"label":"Tooling","variant":"tag-tooling"}]},{"key":"lab-kafka-debezium","title":"Hands-On Lab: Kafka + Debezium","description":"Stand up Kafka, Connect, and Postgres locally with guided copy-paste commands.","href":"/lab-kafka-debezium/","ctaLabel":"Start the Lab","tags":[{"label":"Lab","variant":"tag-labs"}]},{"key":"quickstarts","title":"Quickstarts","description":"Pick your source database and follow a 10‚Äì20 minute setup with checks and commands.","href":"/quickstarts/","ctaLabel":"View Quickstarts","tags":[{"label":"Lab","variant":"tag-labs"}]},{"key":"tests","title":"Acceptance Tests","description":"Run shell scripts that confirm your lab stack is up, the connector is healthy, and events keep flowing after restarts.","href":"/tests/","ctaLabel":"Verify Your Stack","tags":[{"label":"Lab","variant":"tag-labs"}]},{"key":"connector-builder","title":"Connector Config Builder","description":"Generate Debezium configs for Postgres, MySQL, or Oracle in minutes.","href":"/connector-builder/","ctaLabel":"Launch the Builder","tags":[{"label":"Tooling","variant":"tag-tooling"}]},{"key":"dlq-triage","title":"DLQ Triage Assistant","description":"Guided commands and playbooks for decoding and re-driving Kafka DLQ events.","href":"/dlq-triage/","ctaLabel":"Try the Assistant","tags":[{"label":"Extras","variant":"tag-extras"}]},{"key":"debezium-decoder","title":"Debezium Event Decoder","description":"Paste Kafka events to get before/after diffs and MERGE-ready SQL templates.","href":"/debezium-decoder/","ctaLabel":"Decode an Event","tags":[{"label":"Extras","variant":"tag-extras"}]},{"key":"errata","title":"Nuances & Errata","description":"Corrections, caveats, and sharp edges across CDC: effectively-once vs exactly-once, snapshots & replays, tombstones/compaction, schema evolution, and ops guardrails.","href":"/errata/","ctaLabel":"See nuances","tags":[{"label":"Extras","variant":"tag-extras"}]}];
    </script>
    <script type="module" src="/letstalkcdc/scripts/dashboard.js"></script>
    <script type="module" src="/letstalkcdc/assets/js/app.js"></script>
    
    
    
      <script>
        window.CDC_JOURNEY_SLUG = "schema-evolution";
      </script>
      <script type="module" src="/letstalkcdc/scripts/progress.js"></script>
    
    <footer class="site-footer">
      <p>¬© 2025 Christopher Ennis. A deep dive into the world of Change Data Capture.</p>
    </footer>
  </body>
</html>
