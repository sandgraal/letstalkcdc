<!DOCTYPE html>
<html lang="en" data-path-prefix="/letstalkcdc/">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CDC Use Cases &amp; Applications | CDC: The Missing Manual | CDC: The Missing Manual</title>
    <meta name="description" content="Learn why Change Data Capture (CDC) projects fail and how to build scalable, reliable, and production-ready data pipelines.">
    <meta name="robots" content="index,follow,max-image-preview:large">
    <link rel="apple-touch-icon" sizes="180x180" href="/letstalkcdc/apple-touch-icon.png">
    <link rel="icon" href="/letstalkcdc/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="/letstalkcdc/favicon.ico">
    
    
      
      
    
    
    <link rel="canonical" href="https://letstalkcdc.github.io/letstalkcdc/use-cases/">
    <meta name="theme-color" content="#0f172a">
    <meta
      content="Explore real-world CDC use cases, including real-time data warehousing, cache invalidation, auditing, microservices integration, and full-text search indexing."
      name="description"
    />
<link rel="stylesheet" href="{{ '/assets/css/pages/use-cases.css' | url }}">

    <link rel="stylesheet" href="/letstalkcdc/assets/css/styles.css">
    <link rel="stylesheet" href="/letstalkcdc/css/dashboard.css">
  </head>
  <body data-journey-slug="use-cases">
    <a class="skip-link" href="#main">Skip to content</a>
    <header class="global-header">
      <div class="nav-container">
        <a class="site-title" href="/letstalkcdc/">CDC: The Missing Manual | A Deep Dive into Change Data Capture</a>
        <div class="nav-right">
          <nav aria-label="Primary" class="nav-links">
            <a class="" href="/letstalkcdc/">Home</a>
            <a class="" href="/letstalkcdc/overview/">The Series</a>
          </nav>
          <button aria-label="Toggle dark mode" class="theme-toggle" data-toggle-theme type="button">üåì</button>
        </div>
      </div>
    </header>

    <main id="main">


  <section class="hero-section hero-align-center">
    <div class="hero-container container">
      <div class="prose">
        
        <h1 class="type-display">CDC in the Wild</h1>
        
          <div class="hero-lede"><p>Explore the real-world patterns powered by change streams‚Äîfrom real-time analytics to cache invalidation and microservice choreography.</p></div>
        
        
          <div class="hero-actions">
            
              <a class="button " href="#warehousing">Analytics &amp; BI</a>
            
              <a class="button ghost" href="#microservices">Microservices Integration</a>
            
          </div>
        
      </div>
    </div>
  </section>

      <article class="prose">
        <p>
          Beyond the theory, Change Data Capture enables a diverse set of
          powerful, real-time applications. Understanding these patterns is key
          to unlocking the strategic value of your data. Each use case
          demonstrates a shift from slow, periodic batch processing to a
          continuous, event-driven paradigm.
        </p>

        <section class="use-case-section" id="warehousing">
          <h3>Use Case 1: Analytics & Business Intelligence</h3>
          <h2>From Batch ETL to Real-Time ELT</h2>
          <p>
            <strong>The Problem:</strong> Business decisions based on stale,
            24-hour-old data are a competitive liability. Traditional nightly
            ETL jobs place a heavy, recurring load on production databases and
            deliver insights that are already out of date.
          </p>
          <p>
            <strong>The CDC Solution:</strong> Log-based CDC continuously
            streams every row-level change from operational (OLTP) databases.
            These events flow through a streaming platform like Kafka and are
            loaded into an analytical data warehouse (Snowflake, BigQuery,
            Redshift) in near real-time. The warehouse uses `MERGE` or `UPSERT`
            operations to efficiently apply these granular changes, keeping
            analytical tables perfectly synchronized with the source.
          </p>
          <div class="seq" role="group" aria-label="Warehousing flow">
            <div class="seq-head">Producer (OLTP/CDC)</div>
            <div class="seq-head">Streaming Platform</div>
            <div class="seq-head">Warehouse</div>
            <div class="seq-cell">CDC tails DB changes</div>
            <div class="seq-cell">Publish to Kafka topic(s)</div>
            <div class="seq-cell">Connector reads</div>
            <div class="seq-cell">‚Äî</div>
            <div class="seq-cell">‚Äî</div>
            <div class="seq-cell"><code>MERGE/UPSERT</code> into models</div>
          </div>
          <p><strong>The Business Impact:</strong></p>
          <ul class="impact-list">
            <li>
              <strong>Accelerated Decision-Making:</strong> BI dashboards and
              reports reflect business operations up to the minute, not up to
              the day.
            </li>
            <li>
              <strong>Reduced Database Load:</strong> Eliminates the need for
              resource-intensive, full-table scans during nightly batch windows,
              improving source system performance.
            </li>
            <li>
              <strong>Fresher Data for ML:</strong> Machine learning models can
              be trained and served with more current data, improving prediction
              accuracy.
            </li>
          </ul>
        </section>

        <section class="use-case-section" id="microservices">
          <h3>Use Case 2: System Architecture</h3>
          <h2>Asynchronous Microservice Integration</h2>
          <p>
            <strong>The Problem:</strong> Services in a microservices
            architecture need to share data, but direct, synchronous API calls
            create tight coupling. If one service is down, it can cause a
            cascade of failures in the services that depend on it.
          </p>
          <p>
            <strong>The CDC Solution:</strong> CDC enables the
            <strong>Event-Carried State Transfer</strong> pattern via the
            Transactional Outbox. When a service makes a change (an `orders`
            service creates an order), it writes the business data and an event
            record to an "outbox" table in the same atomic transaction. The CDC
            agent streams only the committed outbox events to a Kafka topic.
            Downstream services (shipping`, `billing`) simply subscribe to this
            topic to receive guaranteed, in-order state changes without ever
            calling the `orders` service directly.
          </p>
          <div class="seq" role="group" aria-label="Outbox integration flow">
            <div class="seq-head">Producer (Service A)</div>
            <div class="seq-head">Kafka</div>
            <div class="seq-head">Consumers (B/C)</div>
            <div class="seq-cell">Write business row + outbox (same txn)</div>
            <div class="seq-cell">CDC publishes outbox events</div>
            <div class="seq-cell">Subscribe to topic</div>
            <div class="seq-cell">‚Äî</div>
            <div class="seq-cell">‚Äî</div>
            <div class="seq-cell">Idempotent upserts; no sync coupling</div>
          </div>
          <p><strong>The Business Impact:</strong></p>
          <ul class="impact-list">
            <li>
              <strong>Increased Resilience:</strong> Services are decoupled. The
              `shipping` service can continue processing events even if the
              `orders` service is temporarily unavailable.
            </li>
            <li>
              <strong>Improved Scalability:</strong> Services can be scaled
              independently. You can add more `billing` consumers without
              affecting the `orders` service.
            </li>
            <li>
              <strong>Enhanced Service Autonomy:</strong> Each team can evolve
              its service and database schema without breaking downstream
              consumers, as long as the event contract is maintained.
            </li>
          </ul>
        </section>
        <section class="use-case-section" id="search-indexing">
          <h3>Use Case 5: Discovery & Search</h3>
          <h2>Near-Real-Time Full-Text Search Indexing</h2>
          <p>
            <strong>The Problem:</strong> Rebuilding a search index from scratch
            (hourly/daily) is wasteful and makes ‚Äúsearch lag‚Äù a constant
            complaint.
          </p>
          <p>
            <strong>The CDC Solution:</strong> Stream row-level changes into a
            lightweight transformer that denormalizes documents and ships them
            to Elasticsearch/OpenSearch/Solr. <em>Upsert</em> on create/update;
            <em>delete</em> on tombstones. Use a deterministic
            <code>doc_id</code> to make replays idempotent.
          </p>
          <div class="seq" role="group" aria-label="Search indexing flow">
            <div class="seq-head">Source/CDC</div>
            <div class="seq-head">Doc Builder / Enricher</div>
            <div class="seq-head">Search Index</div>
            <div class="seq-cell">Row-level change events</div>
            <div class="seq-cell">Join/denormalize into documents</div>
            <div class="seq-cell">Upsert by <code>doc_id</code></div>
            <div class="seq-cell">Tombstones</div>
            <div class="seq-cell">Mark as delete</div>
            <div class="seq-cell">Delete from index</div>
          </div>
          <p><strong>The Business Impact:</strong></p>
          <ul class="impact-list">
            <li>
              <strong>Fresh search:</strong> New/edited products, profiles, and
              content appear within seconds.
            </li>
            <li>
              <strong>Lower cost:</strong> No more full re-index jobs; only
              incremental updates.
            </li>
            <li>
              <strong>Better relevance:</strong> Can re-score or enrich on the
              fly during the doc build step.
            </li>
          </ul>
        </section>

        <section class="use-case-section" id="feature-stores">
          <h3>Use Case 6: Machine Learning</h3>
          <h2>Real-Time Features & Online/Offline Consistency</h2>
          <p>
            <strong>The Problem:</strong> Batch-built features drift from
            production state; models suffer from ‚Äútraining/serving skew.‚Äù
          </p>
          <p>
            <strong>The CDC Solution:</strong> Feed CDC events into a feature
            pipeline: write <em>offline</em> parquet/Delta/Iceberg tables for
            training and simultaneously upsert <em>online</em> features
            (Redis/DynamoDB/Spanner). Use the same <code>event_id</code>
            and schema contracts so replays are safe and the two stores stay
            consistent.
          </p>
          <div class="seq" role="group" aria-label="Feature store flow">
            <div class="seq-head">Stream Processor</div>
            <div class="seq-head">Offline (Lakehouse)</div>
            <div class="seq-head">Online Feature Store</div>
            <div class="seq-cell">Ingest CDC events</div>
            <div class="seq-cell">Write Parquet/Delta/Iceberg</div>
            <div class="seq-cell">
              Idempotent upserts by <code>entity_id</code>
            </div>
            <div class="seq-cell">Derive features</div>
            <div class="seq-cell">Training datasets</div>
            <div class="seq-cell">Serve features to models</div>
          </div>
          <p><strong>The Business Impact:</strong></p>
          <ul class="impact-list">
            <li>
              <strong>Fresher predictions:</strong> models see current features,
              not yesterday‚Äôs.
            </li>
            <li>
              <strong>Consistency:</strong> identical events power training and
              serving paths.
            </li>
            <li>
              <strong>Faster iteration:</strong> add features with
              schema-checked rollouts.
            </li>
          </ul>
        </section>

        <section class="use-case-section" id="when-not-to-use">
          <h3>Guardrails</h3>
          <h2>When <em>Not</em> to Use CDC (or use with caution)</h2>
          <ul class="impact-list">
            <li>
              <strong>Ultra-high fan-out updates</strong> that require global
              ordering across entities (CDC provides per-key order only).
            </li>
            <li>
              <strong>Compute-heavy transformations</strong> that are cheaper in
              micro-batches; consider a streaming job with windowing instead of
              per-row fan-out.
            </li>
            <li>
              <strong>SaaS sources with unreliable webhooks</strong> without
              replay‚Äîbuffer behind an Inbox/Outbox queue first.
            </li>
            <li>
              <strong>Hard deletes needed but source lacks tombstones</strong>
              (polling CDC) ‚Üí add soft-delete markers or archival tables.
            </li>
          </ul>
        </section>
        <section class="use-case-section" id="auditing">
          <h3>Use Case 3: Security & Compliance</h3>
          <h2>Immutable Auditing and Data Lineage</h2>
          <p>
            <strong>The Problem:</strong> For regulatory compliance (SOX, GDPR,
            HIPAA) and security investigations, organizations need a complete,
            tamper-proof history of all changes made to critical data. Building
            this logic into every application is complex and error-prone.
          </p>
          <p>
            <strong>The CDC Solution:</strong> The stream of events produced by
            log-based CDC *is* a perfect, immutable audit log. Each event
            captures the "before" and "after" state of the data, a precise
            timestamp, the type of operation (`INSERT`, `UPDATE`, `DELETE`), and
            metadata about the transaction. This entire stream can be durably
            archived to low-cost object storage (like Amazon S3), creating a
            verifiable and replayable history of the data's entire lifecycle.
          </p>
          <p><strong>The Business Impact:</strong></p>
          <ul class="impact-list">
            <li>
              <strong>Simplified Compliance:</strong> Easily prove data lineage
              and access patterns to auditors, satisfying strict regulatory
              requirements.
            </li>
            <li>
              <strong>Enhanced Security:</strong> Detect and investigate
              unauthorized or anomalous data changes by analyzing the raw event
              stream.
            </li>
            <li>
              <strong>Faster Debugging:</strong> "Replay" the event stream to
              understand how data reached a corrupted state, drastically
              reducing time-to-resolution for production incidents.
            </li>
          </ul>
        </section>

        <section class="use-case-section" id="cache-invalidation">
          <h3>Use Case 4: Application Performance</h3>
          <h2>Reliable Cache Invalidation</h2>
          <p>
            <strong>The Problem:</strong> Keeping an external cache (like Redis
            or Memcached) synchronized with the database is famously difficult.
            A common failure mode is serving stale data because the application
            logic failed to invalidate the cache after a database write.
          </p>
          <p>
            <strong>The CDC Solution:</strong> This pattern is elegant in its
            simplicity. A lightweight consumer service listens to the CDC stream
            from the primary database. When it receives an `UPDATE` or `DELETE`
            event for a specific record, it issues a corresponding `SET` or
            `DEL` command to the cache for that record's key. The responsibility
            for cache consistency is moved out of the critical application path
            into a simple, reliable, asynchronous process.
          </p>
          <p><strong>The Business Impact:</strong></p>
          <ul class="impact-list">
            <li>
              <strong>Improved User Experience:</strong> Guarantees that users
              are never shown stale data, improving trust and application
              quality.
            </li>
            <li>
              <strong>Simplified Application Code:</strong> Removes complex and
              error-prone cache management logic from the application layer.
            </li>
            <li>
              <strong>Better Performance:</strong> Allows applications to
              confidently and aggressively cache data, reducing load on the
              primary database and improving response times.
            </li>
          </ul>
        </section>
      </article>
</main>

    
      



  

  

  

  

  

  

  

  

  

  

  
    
    
  

  

  

  

  

  

  

  

  

  


  
  
  <div class="container">
    <nav class="series-nav" aria-label="Series navigation">
      <div class="series-nav__group series-nav__group--start">
        
          <a class="series-nav__link series-nav__link--prev" href="/observability/" aria-label="Previous module: Observability Basics">‚Üê Observability Basics</a>
        
      </div>
      <div class="series-nav__group series-nav__group--center">
        <a
          class="series-nav__link series-nav__link--overview"
          href="/letstalkcdc/overview/#series-use-cases"
        >
          Back to Overview
        </a>
      </div>
      <div class="series-nav__group series-nav__group--end">
        
          <a class="series-nav__link series-nav__link--next" href="/strategy/" aria-label="Next module: The Strategic Value of CDC">The Strategic Value of CDC ‚Üí</a>
        
      </div>
    </nav>
    <div class="series-progress" data-progress-toolbar>
      <div class="series-progress__info">
        <span class="series-progress__label">Progress</span>
        <span class="series-progress__value" data-progress-percent>0%</span>
        <span class="series-progress__status" data-progress-status>Not signed in</span>
      </div>
      <div class="series-progress__auth">
        <button type="button" class="button ghost" data-progress-login="github">Sign in with GitHub</button>
        <button type="button" class="button ghost" data-progress-logout hidden>Sign out</button>
      </div>
    </div>
  </div>


    

    <div class="progress-toast" data-progress-toast hidden aria-live="polite">
      <div class="progress-toast__body" role="status">
        <p class="progress-toast__message" data-progress-toast-message></p>
        <div class="progress-toast__actions">
          <button type="button" class="button" data-progress-toast-resume>Resume</button>
          <button type="button" class="button ghost" data-progress-toast-dismiss>Dismiss</button>
        </div>
      </div>
    </div>

    <section class="dashboard-boot container" id="cdcDashboardBoot" aria-live="polite">
      <h2>Let&rsquo;s Talk CDC Session</h2>
      <p>Sign in with your CDC account to unlock the interactive dashboard and sync module progress across devices.</p>
    </section>

    <section class="cdc-dashboard container" id="cdcDashboard" hidden aria-labelledby="cdcDashboardTitle">
      <header>
        <h2 id="cdcDashboardTitle">Let&rsquo;s Talk CDC Interactive Dashboard</h2>
        <p>Track journey completion, monitor recent activity, and export your session logs.</p>
      </header>
      <div class="dashboard-charts">
        <canvas id="cdc-progress-overall" aria-label="Overall progress" role="img"></canvas>
        <canvas id="cdc-progress-modules" aria-label="Module progress" role="img"></canvas>
      </div>
      <div class="dashboard-legend" id="progressLegend" aria-live="polite"></div>
      <div class="dashboard-footer" id="progressFooter" data-last-completed="0" aria-live="polite"></div>
      <div class="agent-console" id="agentConsole" aria-live="polite">
        <div class="agent-scroll" role="log" aria-live="polite" aria-label="CDC agent activity"></div>
      </div>
    </section>

    <div class="stats-wrapper" aria-live="polite">
      <button type="button" class="stats-chip" id="statsButton" aria-haspopup="dialog" aria-controls="sessionModal">
        <span class="sr-only">Open dashboard activity</span>
        <span aria-hidden="true">üìä</span>
        <span class="stats-counter" id="statsCounter">0</span>
      </button>
      <div class="filter-tooltip" id="filterTooltip" role="status" aria-live="assertive">FILTER: all</div>
    </div>

    <div class="session-modal hidden" id="sessionModal" role="dialog" aria-modal="true" aria-labelledby="sessionModalTitle">
      <div class="modal-content">
        <header>
          <h2 id="sessionModalTitle">Session Activity</h2>
        </header>
        <div id="sessionDetails"></div>
        <div class="export-controls">
          <button type="button" id="exportTxt">Export TXT</button>
          <button type="button" id="exportJson">Export JSON</button>
        </div>
        <button type="button" class="button ghost" id="closeModal">Close</button>
      </div>
    </div>

    <script>
      (function () {
        const attr = document.documentElement.dataset.pathPrefix || '/';
        const prefix = attr === '/' ? '' : attr.replace(/\/$/, '');
        window.__PATH_PREFIX__ = prefix;

        if (!prefix) {
          return;
        }

        const rewriteAttribute = (element, attribute) => {
          const value = element.getAttribute(attribute);
          if (!value || value.startsWith('http') || value.startsWith('mailto:') || value.startsWith('tel:') || value.startsWith('#')) {
            return;
          }
          if (!value.startsWith('/') || value.startsWith(prefix)) {
            return;
          }
          element.setAttribute(attribute, `${prefix}${value}`);
        };

        const adjustDom = () => {
          document.querySelectorAll('a[href^="/"]').forEach((el) => rewriteAttribute(el, 'href'));
          document.querySelectorAll('img[src^="/"]').forEach((el) => rewriteAttribute(el, 'src'));
          document.querySelectorAll('script[src^="/"]').forEach((el) => rewriteAttribute(el, 'src'));
          document.querySelectorAll('form[action^="/"]').forEach((el) => rewriteAttribute(el, 'action'));
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', adjustDom, { once: true });
        } else {
          adjustDom();
        }
      })();
    </script>
    <script>
      window.CDC_MODULES = [{"key":"intro","title":"Interactive Introduction to CDC","description":"An interactive dashboard covering core concepts, methods, architectures, and the tooling ecosystem.","href":"/intro/","ctaLabel":"Dive In!","isRecommended":true,"badge":{"label":"Start Here","variant":"recommended"},"tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"event-envelope","title":"Event Envelope & Delivery Guarantees","description":"Keys vs payload, before/after images, tombstones; ALO vs EOS scope and per-key ordering.","href":"/event-envelope/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"materialization","title":"Materialization 101 (Upsert/Delete)","description":"Practical MERGE patterns for upserts & deletes; compaction vs history tables; late-arrivals 101.","href":"/materialization/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"snapshotting","title":"Snapshotting: The First Sync","description":"Learn how CDC pipelines perform the initial, consistent snapshot of a database before streaming live changes.","href":"/snapshotting/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"exactly-once","title":"Exactly-Once Semantics","description":"Visual walkthrough of ALO vs EOS + transactional outbox.","href":"/exactly-once/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"multi-tenancy","title":"Multi-Tenancy","description":"Isolation patterns, topic math, and rough egress estimates.","href":"/multi-tenancy/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"partitioning","title":"Partitioning","description":"Partition keys, skew, late-arrivals, and audit loops.","href":"/partitioning/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"schema-evolution","title":"Schema Evolution","description":"Handle schema changes gracefully with forward/backward compatibility and schema registries.","href":"/schema-evolution/","tags":[{"label":"Advanced Pattern","variant":"tag-pattern"}]},{"key":"ops-offsets","title":"Ops: Offsets & Replays","description":"Offset stores, safe rewind, idempotency, and resync drills when things go sideways.","href":"/ops-offsets/","tags":[{"label":"Ops","variant":"tag-ops"}]},{"key":"observability","title":"Observability Basics","description":"Golden signals (lag, throughput, error rate), alerting, and minimal dashboards to keep.","href":"/observability/","tags":[{"label":"Ops","variant":"tag-ops"}]},{"key":"use-cases","title":"Real-World Use Cases","description":"Explore practical applications of CDC, from real-time analytics to cache invalidation.","href":"/use-cases/","tags":[{"label":"Core Concept","variant":"tag-concept"}]},{"key":"strategy","title":"The Strategic Value of CDC","description":"Understand the business case and philosophical shift behind adopting an event-driven data culture.","href":"/strategy/","tags":[{"label":"Strategy","variant":"tag-strategy"}]},{"key":"tooling","title":"The CDC Ecosystem","description":"A curated overview of the most popular open-source and commercial tools in the landscape (Debezium, Fivetran, etc).","href":"/tooling/","tags":[{"label":"Tooling","variant":"tag-tooling"}]},{"key":"lab-kafka-debezium","title":"Hands-On Lab: Kafka + Debezium","description":"Stand up Kafka, Connect, and Postgres locally with guided copy-paste commands.","href":"/lab-kafka-debezium/","ctaLabel":"Start the Lab","tags":[{"label":"Lab","variant":"tag-labs"}]},{"key":"quickstarts","title":"Quickstarts","description":"Pick your source database and follow a 10‚Äì20 minute setup with checks and commands.","href":"/quickstarts/","ctaLabel":"View Quickstarts","tags":[{"label":"Lab","variant":"tag-labs"}]},{"key":"tests","title":"Acceptance Tests","description":"Run shell scripts that confirm your lab stack is up, the connector is healthy, and events keep flowing after restarts.","href":"/tests/","ctaLabel":"Verify Your Stack","tags":[{"label":"Lab","variant":"tag-labs"}]},{"key":"connector-builder","title":"Connector Config Builder","description":"Generate Debezium configs for Postgres, MySQL, or Oracle in minutes.","href":"/connector-builder/","ctaLabel":"Launch the Builder","tags":[{"label":"Tooling","variant":"tag-tooling"}]},{"key":"dlq-triage","title":"DLQ Triage Assistant","description":"Guided commands and playbooks for decoding and re-driving Kafka DLQ events.","href":"/dlq-triage/","ctaLabel":"Try the Assistant","tags":[{"label":"Extras","variant":"tag-extras"}]},{"key":"debezium-decoder","title":"Debezium Event Decoder","description":"Paste Kafka events to get before/after diffs and MERGE-ready SQL templates.","href":"/debezium-decoder/","ctaLabel":"Decode an Event","tags":[{"label":"Extras","variant":"tag-extras"}]},{"key":"errata","title":"Nuances & Errata","description":"Corrections, caveats, and sharp edges across CDC: effectively-once vs exactly-once, snapshots & replays, tombstones/compaction, schema evolution, and ops guardrails.","href":"/errata/","ctaLabel":"See nuances","tags":[{"label":"Extras","variant":"tag-extras"}]}];
    </script>
    <script type="module" src="/letstalkcdc/scripts/dashboard.js"></script>
    <script type="module" src="/letstalkcdc/assets/js/app.js"></script>
    
    
    
      <script>
        window.CDC_JOURNEY_SLUG = "use-cases";
      </script>
      <script type="module" src="/letstalkcdc/scripts/progress.js"></script>
    
    <footer class="site-footer">
      <p>¬© 2025 Christopher Ennis. A deep dive into the world of Change Data Capture.</p>
    </footer>
  </body>
</html>
