---
layout: base.njk
title: "CDC Nuances & Errata — Read Before You Ship"
description: "Corrections, caveats, and sharp edges in CDC systems."
canonicalPath: "/errata/"
head_extra: |
  <meta
        name="description"
        content="Corrections, caveats, and sharp edges in CDC systems."
      />
---
{% import "components/ui.njk" as ui %}

{{ ui.hero(heroConfig) | safe }}
      <p class="lede">
        A living list of precise clarifications, corrections, and “gotchas”.
        Treat this as pre‑flight checks before promising
        <em>exactly‑once</em> or “zero data loss.”
      </p>

      <section class="panel">
        <h2 id="exactly-once">End‑to‑end <em>exactly‑once</em> vs. <em>effectively‑once</em></h2>
        <ul>
          <li>
            <strong>Source connectors are at‑least‑once</strong> in practice.
            You can achieve <em>effectively‑once</em> by making sinks idempotent
            (UPSERT on stable keys) and/or <em>deduplicating</em> using a
            durable <code>event_id</code> ledger.
          </li>
          <li>
            <strong>Transaction boundaries</strong>: Database transactions map
            to change streams, not to sink transactions unless your pipeline
            coordinates them. Don’t assume cross‑topic atomicity.
          </li>
          <li>
            <strong>Per‑key ordering only</strong>: Ordering is guaranteed per
            partition key (primary/business key). <em>Cross‑entity</em> ordering
            is not guaranteed and shouldn’t be relied upon.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2 id="snapshots">Snapshots, backfills, and replays</h2>
        <ul>
          <li>
            <strong>Initial snapshots</strong> can interleave with live changes;
            design consumers to reconcile using version columns or
            <code>op_ts</code>.
          </li>
          <li>
            <strong>Incremental snapshots</strong> (signal‑based) are powerful
            but can produce duplicates; always merge on keys + highest version
            and keep idempotent sinks.
          </li>
          <li>
            <strong>Backfills</strong> are just another snapshot; isolate them
            (topics/headers) to avoid double‑counting.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Tombstones, compaction, and deletions</h2>
        <ul>
          <li>
            <strong>Tombstones</strong> are required for compaction to fully
            remove keys; keep a non‑zero delete.retention.ms long enough for
            consumers.
          </li>
          <li>
            <strong>Soft‑delete models</strong> still need physical deletes or a
            retention strategy in the sink to avoid data resurrection.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Schema evolution</h2>
        <ul>
          <li>
            Always version <em>payload schemas</em> and keep consumers tolerant
            to <em>additive</em> changes. No producer should introduce breaking
            field removals/renames without a migration window.
          </li>
          <li>
            Use <code>optional</code> + default values judiciously to avoid
            “poison” events.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Operational guardrails</h2>
        <ul>
          <li>
            Watch lag/throughput and <code>max.queue.size</code>,
            <code>max.batch.size</code>, <code>poll.interval.ms</code>.
            Oversizing queue without heap tuning yields GC stalls.
          </li>
          <li>
            Alert on <strong>connector task failures</strong>,
            <strong>restart loops</strong>, and
            <strong>earliest‑offset resets</strong>.
          </li>
          <li>
            Prefer <strong>per‑table connectors</strong> for isolation when SLAs
            differ; otherwise group by SLA and update cadence.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Recommended dedup ledger</h2>
        <pre><code>-- event_id is a stable UUID in headers or payload
create table if not exists dw.processed_event(
  event_id text primary key,
  processed_at timestamptz not null default now()
);</code></pre>
        <p>On ingest:</p>
        <pre><code>insert into dw.processed_event(event_id)
values (:event_id)
on conflict do nothing;</code></pre>
      </section>

      <div class="links" aria-label="useful extras">
        <a href="compose.yaml" download>compose.yaml</a>
        <a href="connectors/postgres-inventory.json" download
          >postgres sample connector</a
        >
        <a href="scripts/register_connector.sh" download
          >register connector script</a
        >
      </div>
